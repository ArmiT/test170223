**Опишите, какие проблемы могут возникнуть при использовании данного кода**

```php
$mysqli = new mysqli("localhost", "my_user", "my_password", "world");

$id = $_GET['id'];

$res = $mysqli->query('SELECT * FROM users WHERE u_id='. $id);

$user = $res->fetch_assoc();
```
Проблемы:
1. Составленный запрос содержит уязвимость, которая потенциально может быть использована для проведения sql-инъекции. 
2. Запрос не полный. Пропущена точка с запятой в конце запроса - этот факт облегчает эксплуатацию sql-инъекций.
3. Для получения входных данных используются глобальные переменные.

SQL-инъекции - вид атак на базы данных, который позволяет путем подстановки валидных выражений в изменяемые части запроса, 
поменять его поведение - вернуть или изменить данные/структуру.

В примере выше данные, получаемые из транспорта (http-запрос) подставляются в текст sql-запроса в неизменном виде. 
Переменная `$id` просто конкатенируется со строкой запроса + в конце нет точки с запятой (запрос не полный), 
что позволяет не вставлять комментарий в конце инжектируемого кода для игнорирования оставшейся части запроса.

Т.е. возможны варианты исполнения запроса вида:
```sql
SELECT * FROM users WHERE u_id = 0 UNION SELECT * FROM users WHERE username=’admin’ limit 1;
```

Что можно сделать:
1. Форматировать переменные перед использованием в запросе. В случае, если ожидается целое число - просто привести к числу. 
Если строка - использовать метод `real_escape_string` или функцию `mysqli_real_escape_string`.
2. Использовать `prepared statements`. В изменяемых частях запроса устанавливать плейсхолдеры. 
Далее выполнять `bind` реальных значений. Этот способ имеет преимущество перед первым, 
т.к. в этом случае СУБД самостоятельно осуществляет подготовку шаблона запроса (разбор и кэширование плана выполнения), 
а также обеспечивает безопасную вставку данных перед его выполнением.

По 3 проблеме...

Прямое обращение к массивам входных параметров во множестве точек вызова приводит либо к появлению шаблонного кода например, такого вида: 

```php
$id = isset($_GET['id']) ? (int) $_GET['id']: 'default value';
```

Либо отсутствию подготовки таких параметров вообще (как в примере из задания).

Обычно, рекомендуют абстрагировать (инкапсулировать) работу с такими данными, реализовав функции или отдельный класс для этих целей.
